# FakeTube

This is just small project for job interview.

How to run:

1. Add `shared/youtube.env` file with YT_API_KEY, YT_CLIENT_ID, YT_CLIENT_SECRET and YT_REFRESH_TOKEN variables
2. Add `shared/rails.env` file with SECRET_KEY_BASE variable
3. Install Docker and Docker Compose
4. `docker-compose run backend-rails rails db:setup`
5. `docker-compose up`
6. Go to http://localhost:8080

To switch into fast backend use `localStorage.server = window.server = "http://localhost:4568/"` in JS console.

To switch into Rails backend, use port 3000 in JS code above.

# Изначальная постановка задачи

Сделать приложение, позволяющее пользователю залить видео в любом формате, указать некоторую строку.
Данная строка должна быть наложена на видео в виде водяного знака.

Страницы в приложении:

1. Индекс видео, размещены превью-картинки видео, информация о длительности и размере
2. Просмотр конкретного видео, должен быть html5 плеер, видео должно играться на любых устройствах и браузерах.
3. Страница добавления видео.
4. Страница редактирования видео (редактировать можно водяной знак).

Верстка адаптивная.
Код приложения должен быть размещен на github.
В качестве ответа ссылку на репозиторий.
Все прочее на усмотрение соискателя.

# Комментарии для проверяющего (расширенная версия)

1. Так как задание не конкретизировало, что нужно заниматься конвертацией видео и накладыванием водяного знака на сервере, используя всяческие ffmpeg, а также что html плеер должен быть самописным, я решил, что такое неудачное, на мой взгляд, решение делать не стоит, вместо этого лучше делегировать данные задачи сервисам, которые прекрасно с ними справляются: YouTube и Embedly (можно и без Embedly, но он позволяет в перспективе добавить и другие видеосервисы и виды медиа, а также оборачивать в плеер видео со своих серверов). С ffmpeg я работал когда-то, но думаю, что в наше время облачных технологий такое велосипедостроение часто бывает во вред. А, да, а водяной знак я наложил просто через html. :) Для пользователя ведь без разницы.
2. Сначала я написал простое решение на Sinatra (backend-simple), нацеленное на максимально быстрое достижение результата. Затем построил фронтенд в виде простого SPA без препроцессоров на Riot.js. Затем, так как у меня осталось время, я решил сделать более продвинутое решение, ведь Вы хотите оценить мои навыки в бекэнде и оптимизации. :) Поэтому я сделал второй вариант (backend-fast) на голой EventMachine, мимикрирующей HTTP протокол и заливающей видео стриммингом (без буферизации в файле и памяти как в случае Синатры). Это куда более быстрое и масштабируемое решение. Мне не хватило времени на нагрузочное тестирование, но я уверен, что оно быстрее большинства рубишных серверов, т.к. не основано на Rack и гораздо проще. Класс FiberIO также самописный, мимикрирует класс IO для совместимости с Net::HTTP.
3. В планах было также сделать третий вариант: кластер из backend-fast-сервером с брокером, чтобы показать перспективы масштабирования и возможности делать это через docker-compose scale. К сожалению, на это не хватило времени, но такая задача не видится мне сильно сложной.
4. К сожалению, мне не хватило времени на тесты, хотя я и начал их писать. Здесь можно сделать как юнит-тесты, так и интеграционные по API и с фронтэндом через Selenium. Могу их доделать.
5. Безусловно, у текущего решения есть множество недостатков. Я их осознаю. Многие из них за отведённое время избежать, на мой взгляд, проблематично. Например, проблему с кешированием видео в геме yt при заливке нужно исследовать подробнее, т.к. переподключение никуда не годится. На фронтэнде не подключена система локализации, нет server side rendering, а внешние js хорошо бы упаковать в один локальный вместе с заранее скомпилированными riot-тегами. Решение на EventMachine крайне чувствительно к соблюдению стандартов протокола HTTP, в этом направлении можно поработать для улучшения стабильности. Сайт не проверялся в IE и на старых Android, так что я допускаю, что там может что-то не работать. Все эти недостатки я могу устранить в рабочем порядке, при более тщательном анализе могу отыскать и другие проблемы.
6. Классический бекэнд на Rails с использованием Sidekiq, Paperclip, ffmpeg и т. д. был добавлен по дополнительной просьбе работодателя. Фронтэнд универсальный для всех бекэндов.